<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://www.flint.com/flint-lang"
           xmlns:f="http://www.flint.com/flint-lang"
           elementFormDefault="qualified">


    <xs:element name="compilationUnit" type="f:compilationUnit"/>
    <xs:complexType name="compilationUnit">
        <xs:sequence>
            <xs:element ref="f:packageDeclaration" minOccurs="0"/>
            <xs:element ref="f:importDeclaration" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:typeDeclaration" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="packageDeclaration" type="f:packageDeclaration"/>
    <xs:complexType name="packageDeclaration">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="importDeclaration" type="f:importDeclaration"/>
    <xs:complexType name="importDeclaration">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="typeDeclaration" type="f:typeDeclaration"/>
    <xs:complexType name="typeDeclaration">
        <xs:choice>
            <xs:element ref="f:classDeclaration"/>
            <xs:element ref="f:interfaceDeclaration"/>
        </xs:choice>
    </xs:complexType>



    <xs:element name="classDeclaration" type="f:classDeclaration"/>
    <xs:complexType name="classDeclaration">
        <xs:sequence>
            <xs:element ref="f:classModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="className" type="f:simpleTypeName"/>
            <xs:element name="superClass" type="f:qualifiedIdentifier" minOccurs="0"/>
            <xs:element name="superInterfaces" type="f:interfaceType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:classBodyDeclaration"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="classModifier" type="f:classModifier"/>
    <xs:complexType name="classModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:protected"/>
            <xs:element ref="f:private"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:abstract"/>
            <xs:element ref="f:strictfp"/>
        </xs:choice>
    </xs:complexType>



    <xs:element name="classBodyDeclaration" type="f:classBodyDeclaration"/>
    <xs:complexType name="classBodyDeclaration">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="f:fieldDeclaration"/>
            <xs:element ref="f:constructorDeclaration"/>
            <xs:element ref="f:methodDeclaration"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="fieldDeclaration" type="f:fieldDeclaration"/>
    <xs:complexType name="fieldDeclaration">
        <xs:sequence>
            <xs:element ref="f:fieldModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclarator" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="fieldModifier" type="f:fieldModifier"/>
    <xs:complexType name="fieldModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:protected"/>
            <xs:element ref="f:private"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:final"/>
            <xs:element ref="f:volatile"/>
        </xs:choice>
    </xs:complexType>



    <xs:element name="variableDeclarator" type="f:variableDeclarator"/>
    <xs:complexType name="variableDeclarator">
        <xs:sequence>
            <xs:element ref="f:variableDeclaratorId"/>
            <xs:sequence minOccurs="0">
                <xs:element ref="f:variableInitializer"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="variableDeclaratorId" type="f:variableDeclaratorId"/>
    <xs:complexType name="variableDeclaratorId">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
            <xs:element ref="f:dims" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="variableInitializer" type="f:variableInitializer"/>
    <xs:complexType name="variableInitializer">
        <xs:choice>
            <xs:element ref="f:expression"/>
            <xs:element ref="f:arrayInitializer"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="unannType" type="f:unannType"/>
    <xs:complexType name="unannType">
        <xs:choice>
            <xs:element ref="f:unannPrimitiveType"/>
            <xs:element ref="f:unannReferenceType"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="unannPrimitiveType" type="f:unannPrimitiveType"/>
    <xs:complexType name="unannPrimitiveType">
        <xs:choice>
            <xs:element ref="f:numericType"/>
            <xs:element ref="f:boolean"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="unannReferenceType" type="f:unannReferenceType"/>
    <xs:complexType name="unannReferenceType">
        <xs:choice>
            <xs:element ref="f:qualifiedIdentifier"/>
            <xs:element ref="f:unannArrayType"/>
        </xs:choice>
    </xs:complexType>



    <xs:element name="unannClassType" type="f:unannClassType"/>
    <xs:complexType name="unannClassType">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="unannInterfaceType" type="f:unannInterfaceType"/>
    <xs:complexType name="unannInterfaceType">
        <xs:sequence>
            <xs:element ref="f:unannClassType"/>
        </xs:sequence>
    </xs:complexType>



    <xs:element name="unannArrayType" type="f:unannArrayType"/>
    <xs:complexType name="unannArrayType">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:unannPrimitiveType"/>
                <xs:element ref="f:dims"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:qualifiedIdentifier"/>
                <xs:element ref="f:dims"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="methodDeclaration" type="f:methodDeclaration"/>
    <xs:complexType name="methodDeclaration">
        <xs:sequence>
            <xs:element ref="f:methodModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:methodHeader"/>
            <xs:element ref="f:methodBody"/>
        </xs:sequence>
    </xs:complexType>



    <xs:element name="methodModifier" type="f:methodModifier"/>
    <xs:complexType name="methodModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:protected"/>
            <xs:element ref="f:private"/>
            <xs:element ref="f:abstract"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:final"/>
            <xs:element ref="f:native"/>
            <xs:element ref="f:strictfp"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="methodHeader" type="f:methodHeader"/>
    <xs:complexType name="methodHeader">
        <xs:sequence>
            <xs:element ref="f:result"/>
            <xs:element ref="f:methodDeclarator"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="methodDeclarator" type="f:methodDeclarator"/>
    <xs:complexType name="methodDeclarator">
        <xs:sequence>
            <xs:element name="methodName" type="f:identifier"/>
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:formalParameterList" minOccurs="0"/>
<!--            <xs:element ref="f:rightParen"/>-->
<!--            <xs:element ref="f:dims" minOccurs="0"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="formalParameterList" type="f:formalParameterList"/>
    <xs:complexType name="formalParameterList">
        <xs:sequence>
            <xs:element ref="f:formalParameter" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="result" type="f:result"/>
    <xs:complexType name="result">
        <xs:choice>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:void"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="variableModifier" type="f:variableModifier"/>
    <xs:complexType name="variableModifier">
        <xs:choice>
            <xs:element ref="f:final"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="receiverParameter" type="f:receiverParameter"/>
    <xs:complexType name="receiverParameter">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
            <xs:element ref="f:this"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="methodBody" type="f:methodBody"/>
    <xs:complexType name="methodBody">
        <xs:sequence>
            <xs:element ref="f:block"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="constructorDeclaration" type="f:constructorDeclaration"/>
    <xs:complexType name="constructorDeclaration">
        <xs:sequence>
            <xs:element ref="f:constructorModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:constructorDeclarator"/>
<!--            <xs:element ref="f:throws" minOccurs="0"/>-->
            <xs:element ref="f:constructorBody"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="constructorModifier" type="f:constructorModifier"/>
    <xs:complexType name="constructorModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:protected"/>
            <xs:element ref="f:private"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="constructorDeclarator" type="f:constructorDeclarator"/>
    <xs:complexType name="constructorDeclarator">
        <xs:sequence>
            <xs:element name="className" type="f:simpleTypeName"/>
            <xs:element ref="f:formalParameterList"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="formalParameter" type="f:formalParameter"/>
    <xs:complexType name="formalParameter">
        <xs:sequence>
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclaratorId"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="simpleTypeName" type="f:simpleTypeName"/>
    <xs:complexType name="simpleTypeName">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="constructorBody" type="f:constructorBody"/>
    <xs:complexType name="constructorBody">
        <xs:sequence>
            <xs:element ref="f:explicitConstructorInvocation" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:blockStatements"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="explicitConstructorInvocation" type="f:explicitConstructorInvocation"/>
    <xs:complexType name="explicitConstructorInvocation">
        <xs:sequence>
            <xs:choice>
                <xs:element ref="f:this"/>
                <xs:element ref="f:super"/>
            </xs:choice>
            <xs:element ref="f:argumentList"/>
        </xs:sequence>
    </xs:complexType>


<!--    <xs:element name="interfaceDeclaration" type="f:interfaceDeclaration"/>-->
<!--    <xs:complexType name="interfaceDeclaration">-->
<!--        <xs:choice>-->
<!--            <xs:element ref="f:normalInterfaceDeclaration"/>-->
<!--            <xs:element ref="f:annotationTypeDeclaration"/>-->
<!--        </xs:choice>-->
<!--    </xs:complexType>-->


    <xs:element name="interfaceDeclaration" type="f:interfaceDeclaration"/>
    <xs:complexType name="interfaceDeclaration">
        <xs:sequence>
            <xs:element ref="f:interfaceModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="interfaceName" type="f:identifier"/>
            <xs:element name="extendsInterfaces" type="f:interfaceType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:interfaceBody"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="interfaceModifier" type="f:interfaceModifier"/>
    <xs:complexType name="interfaceModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:protected"/>
            <xs:element ref="f:private"/>
            <xs:element ref="f:abstract"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:strictfp"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="extendsInterfaces" type="f:extendsInterfaces"/>
    <xs:complexType name="extendsInterfaces">
        <xs:sequence>
<!--            <xs:element ref="f:extends"/>-->
            <xs:element ref="f:identifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="interfaceBody" type="f:interfaceBody"/>
    <xs:complexType name="interfaceBody">
        <xs:sequence>
            <xs:element ref="f:interfaceMethodDeclaration" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>



    <xs:element name="constantDeclaration" type="f:constantDeclaration"/>
    <xs:complexType name="constantDeclaration">
        <xs:sequence>
            <xs:element ref="f:constantModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclarator" maxOccurs="unbounded"/>

        </xs:sequence>
    </xs:complexType>

    <xs:element name="constantModifier" type="f:constantModifier"/>
    <xs:complexType name="constantModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:final"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="interfaceMethodDeclaration" type="f:interfaceMethodDeclaration"/>
    <xs:complexType name="interfaceMethodDeclaration">
        <xs:sequence>
<!--            <xs:element ref="f:interfaceMethodModifier" minOccurs="0" maxOccurs="unbounded"/>-->
            <xs:element ref="f:methodHeader"/>
            <xs:element ref="f:methodBody"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="interfaceMethodModifier" type="f:interfaceMethodModifier"/>
    <xs:complexType name="interfaceMethodModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:abstract"/>
            <xs:element ref="f:default"/>
            <xs:element ref="f:static"/>
            <xs:element ref="f:strictfp"/>
        </xs:choice>
    </xs:complexType>

<!--    <xs:element name="annotationTypeDeclaration" type="f:annotationTypeDeclaration"/>-->
<!--    <xs:complexType name="annotationTypeDeclaration">-->
<!--        <xs:sequence>-->
<!--            <xs:element ref="f:interfaceModifier" minOccurs="0" maxOccurs="unbounded"/>-->
<!--&lt;!&ndash;            <xs:element ref="f:at"/>&ndash;&gt;-->
<!--            <xs:element ref="f:identifier"/>-->
<!--            <xs:element ref="f:annotationTypeBody"/>-->
<!--        </xs:sequence>-->
<!--    </xs:complexType>-->

    <xs:element name="annotationTypeBody" type="f:annotationTypeBody"/>
    <xs:complexType name="annotationTypeBody">
        <xs:sequence>

            <xs:element ref="f:annotationTypeMemberDeclaration" minOccurs="0" maxOccurs="unbounded"/>

        </xs:sequence>
    </xs:complexType>

    <xs:element name="annotationTypeMemberDeclaration" type="f:annotationTypeMemberDeclaration"/>
    <xs:complexType name="annotationTypeMemberDeclaration">
        <xs:choice>
            <xs:element ref="f:annotationTypeElementDeclaration"/>
            <xs:element ref="f:constantDeclaration"/>
            <xs:element ref="f:classDeclaration"/>
            <xs:element ref="f:interfaceDeclaration"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="annotationTypeElementDeclaration" type="f:annotationTypeElementDeclaration"/>
    <xs:complexType name="annotationTypeElementDeclaration">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:annotationTypeElementModifier" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="f:unannType"/>
                <xs:element ref="f:identifier"/>
<!--                <xs:element ref="f:leftParen"/>-->
<!--                <xs:element ref="f:rightParen"/>-->
                <xs:element ref="f:dims" minOccurs="0"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:defaultValue" minOccurs="0"/>
<!--                <xs:element ref="f:semicolon"/>-->
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="annotationTypeElementModifier" type="f:annotationTypeElementModifier"/>
    <xs:complexType name="annotationTypeElementModifier">
        <xs:choice>
            <xs:element ref="f:public"/>
            <xs:element ref="f:abstract"/>
        </xs:choice>
    </xs:complexType>


    <xs:element name="defaultValue" type="f:defaultValue"/>
    <xs:complexType name="defaultValue">
        <xs:sequence>
            <xs:element ref="f:default"/>
            <xs:element ref="f:elementValue"/>
        </xs:sequence>
    </xs:complexType>



    <xs:element name="elementValue" type="f:elementValue"/>
    <xs:complexType name="elementValue">
        <xs:choice>
            <xs:element ref="f:conditionalExpression"/>
            <xs:element ref="f:elementValueArrayInitializer"/>
<!--            <xs:element ref="f:annotation"/>-->
        </xs:choice>
    </xs:complexType>

    <xs:element name="elementValueArrayInitializer" type="f:elementValueArrayInitializer"/>
    <xs:complexType name="elementValueArrayInitializer">
        <xs:sequence>
<!--            <xs:element ref="f:leftBrace"/>-->
            <xs:element ref="f:elementValueList" minOccurs="0"/>
<!--            <xs:element ref="f:comma" minOccurs="0"/>-->
<!--            <xs:element ref="f:rightBrace"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="elementValueList" type="f:elementValueList"/>
    <xs:complexType name="elementValueList">
        <xs:sequence>
            <xs:element ref="f:elementValue"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
<!--                <xs:element ref="f:comma"/>-->
                <xs:element ref="f:elementValue"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="arrayInitializer" type="f:arrayInitializer"/>
    <xs:complexType name="arrayInitializer">
        <xs:sequence>
<!--            <xs:element ref="f:leftBrace"/>-->
            <xs:element ref="f:variableInitializerList" minOccurs="0"/>
<!--            <xs:element ref="f:comma" minOccurs="0"/>-->
<!--            <xs:element ref="f:rightBrace"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="variableInitializerList" type="f:variableInitializerList"/>
    <xs:complexType name="variableInitializerList">
        <xs:sequence>
            <xs:element ref="f:variableInitializer"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
<!--                <xs:element ref="f:comma"/>-->
                <xs:element ref="f:variableInitializer"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="block" type="f:block"/>
    <xs:complexType name="block">
        <xs:sequence>
<!--            <xs:element ref="f:leftBrace"/>-->
            <xs:element ref="f:blockStatements" minOccurs="0"/>
<!--            <xs:element ref="f:rightBrace"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="blockStatements" type="f:blockStatements"/>
    <xs:complexType name="blockStatements">
        <xs:sequence>
            <xs:element ref="f:blockStatement" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="blockStatement" type="f:blockStatement"/>
    <xs:complexType name="blockStatement">
        <xs:choice>
            <xs:element ref="f:localVariableDeclarationStatement"/>
            <xs:element ref="f:classDeclaration"/>
            <xs:element ref="f:statement"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="localVariableDeclarationStatement" type="f:localVariableDeclarationStatement"/>
    <xs:complexType name="localVariableDeclarationStatement">
        <xs:sequence>
            <xs:element ref="f:localVariableDeclaration"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="localVariableDeclaration" type="f:localVariableDeclaration"/>
    <xs:complexType name="localVariableDeclaration">
        <xs:sequence>
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclarator" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="statement" type="f:statement"/>
    <xs:complexType name="statement">
        <xs:choice>
            <xs:element ref="f:statementWithoutTrailingSubstatement"/>
            <xs:element ref="f:forStatement"/>
            <xs:element ref="f:labeledStatement"/>
            <xs:element ref="f:ifThenStatement"/>
            <xs:element ref="f:ifThenElseStatement"/>
            <xs:element ref="f:whileStatement"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="statementNoShortIf" type="f:statementNoShortIf"/>
    <xs:complexType name="statementNoShortIf">
        <xs:choice>
            <xs:element ref="f:statementWithoutTrailingSubstatement"/>
            <xs:element ref="f:labeledStatementNoShortIf"/>
            <xs:element ref="f:ifThenElseStatementNoShortIf"/>
            <xs:element ref="f:whileStatementNoShortIf"/>
            <xs:element ref="f:forStatementNoShortIf"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="statementWithoutTrailingSubstatement" type="f:statementWithoutTrailingSubstatement"/>
    <xs:complexType name="statementWithoutTrailingSubstatement">
        <xs:choice>
            <xs:element ref="f:block"/>
            <xs:element ref="f:expressionStatement"/>
            <xs:element ref="f:switchStatement"/>
            <xs:element ref="f:doStatement"/>
            <xs:element ref="f:breakStatement"/>
            <xs:element ref="f:continueStatement"/>
            <xs:element ref="f:returnStatement"/>
<!--            <xs:element ref="f:synchronizedStatement"/>-->
<!--            <xs:element ref="f:throwStatement"/>-->
<!--            <xs:element ref="f:tryStatement"/>-->
        </xs:choice>
    </xs:complexType>


    <xs:element name="labeledStatement" type="f:labeledStatement"/>
    <xs:complexType name="labeledStatement">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="labeledStatementNoShortIf" type="f:labeledStatementNoShortIf"/>
    <xs:complexType name="labeledStatementNoShortIf">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
<!--            <xs:element ref="f:colon"/>-->
            <xs:element ref="f:statementNoShortIf"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="expressionStatement" type="f:expressionStatement"/>
    <xs:complexType name="expressionStatement">
        <xs:sequence>
            <xs:element ref="f:statementExpression"/>
<!--            <xs:element ref="f:semicolon"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="statementExpression" type="f:statementExpression"/>
    <xs:complexType name="statementExpression">
        <xs:choice>
            <xs:element ref="f:assignment"/>
            <xs:element ref="f:preIncrementExpression"/>
            <xs:element ref="f:preDecrementExpression"/>
            <xs:element ref="f:postIncrementExpression"/>
            <xs:element ref="f:postDecrementExpression"/>
            <xs:element ref="f:methodInvocation"/>
            <xs:element ref="f:classInstanceCreationExpression"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="ifThenStatement" type="f:ifThenStatement"/>
    <xs:complexType name="ifThenStatement">
        <xs:sequence>
<!--            <xs:element ref="f:if"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="ifThenElseStatement" type="f:ifThenElseStatement"/>
    <xs:complexType name="ifThenElseStatement">
        <xs:sequence>
<!--            <xs:element ref="f:if"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statementNoShortIf"/>
<!--            <xs:element ref="f:else"/>-->
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="ifThenElseStatementNoShortIf" type="f:ifThenElseStatementNoShortIf"/>
    <xs:complexType name="ifThenElseStatementNoShortIf">
        <xs:sequence>
<!--            <xs:element ref="f:if"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statementNoShortIf"/>
<!--            <xs:element ref="f:else"/>-->
            <xs:element ref="f:statementNoShortIf"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="switchStatement" type="f:switchStatement"/>
    <xs:complexType name="switchStatement">
        <xs:sequence>
<!--            <xs:element ref="f:switch"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:switchBlock"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="switchBlock" type="f:switchBlock"/>
    <xs:complexType name="switchBlock">
        <xs:sequence>
<!--            <xs:element ref="f:leftBrace"/>-->
            <xs:element ref="f:switchBlockStatementGroup" minOccurs="0"/>
            <xs:element ref="f:switchLabel" minOccurs="0"/>
<!--            <xs:element ref="f:rightBrace"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="switchBlockStatementGroup" type="f:switchBlockStatementGroup"/>
    <xs:complexType name="switchBlockStatementGroup">
        <xs:sequence>
            <xs:element ref="f:switchLabels"/>
            <xs:element ref="f:blockStatements"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="switchLabels" type="f:switchLabels"/>
    <xs:complexType name="switchLabels">
        <xs:sequence>
            <xs:element ref="f:switchLabel"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="f:switchLabel"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="switchLabel" type="f:switchLabel"/>
    <xs:complexType name="switchLabel">
        <xs:choice>
            <xs:sequence>
<!--                <xs:element ref="f:case"/>-->

                <xs:choice>

                    <xs:sequence>
                        <xs:element ref="f:constantExpression"/>

                    </xs:sequence>

                    <xs:sequence>
                        <xs:element ref="f:enumConstantName"/>
<!--                        <xs:element ref="f:colon"/>-->
                    </xs:sequence>

                </xs:choice>
            </xs:sequence>

            <xs:sequence>
                <xs:element ref="f:default"/>

            </xs:sequence>

        </xs:choice>
    </xs:complexType>

    <xs:element name="enumConstantName" type="f:enumConstantName"/>
    <xs:complexType name="enumConstantName">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="whileStatement" type="f:whileStatement"/>
    <xs:complexType name="whileStatement">
        <xs:sequence>
<!--            <xs:element ref="f:while"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="whileStatementNoShortIf" type="f:whileStatementNoShortIf"/>
    <xs:complexType name="whileStatementNoShortIf">
        <xs:sequence>
<!--            <xs:element ref="f:while"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statementNoShortIf"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="doStatement" type="f:doStatement"/>
    <xs:complexType name="doStatement">
        <xs:sequence>
<!--            <xs:element ref="f:do"/>-->
            <xs:element ref="f:statement"/>
<!--            <xs:element ref="f:while"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
<!--            <xs:element ref="f:semicolon"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="forStatement" type="f:forStatement"/>
    <xs:complexType name="forStatement">
        <xs:choice>
            <xs:element ref="f:basicForStatement"/>
            <xs:element ref="f:enhancedForStatement"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="forStatementNoShortIf" type="f:forStatementNoShortIf"/>
    <xs:complexType name="forStatementNoShortIf">
        <xs:choice>
            <xs:element ref="f:basicForStatementNoShortIf"/>
            <xs:element ref="f:enhancedForStatementNoShortIf"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="basicForStatement" type="f:basicForStatement"/>
    <xs:complexType name="basicForStatement">
        <xs:sequence>
<!--            <xs:element ref="f:for"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:forInit" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
            <xs:element ref="f:expression" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
            <xs:element ref="f:forUpdate" minOccurs="0"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="basicForStatementNoShortIf" type="f:basicForStatementNoShortIf"/>
    <xs:complexType name="basicForStatementNoShortIf">
        <xs:sequence>
<!--            <xs:element ref="f:for"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:forInit" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
            <xs:element ref="f:expression" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
            <xs:element ref="f:forUpdate" minOccurs="0"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statementNoShortIf"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="forInit" type="f:forInit"/>
    <xs:complexType name="forInit">
        <xs:choice>
            <xs:element ref="f:statementExpressionList"/>
            <xs:element ref="f:localVariableDeclaration"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="forUpdate" type="f:forUpdate"/>
    <xs:complexType name="forUpdate">
        <xs:sequence>
            <xs:element ref="f:statementExpressionList"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="statementExpressionList" type="f:statementExpressionList"/>
    <xs:complexType name="statementExpressionList">
        <xs:sequence>
            <xs:element ref="f:statementExpression"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
<!--                <xs:element ref="f:comma"/>-->
                <xs:element ref="f:statementExpression"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="enhancedForStatement" type="f:enhancedForStatement"/>
    <xs:complexType name="enhancedForStatement">
        <xs:sequence>
<!--            <xs:element ref="f:for"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclaratorId"/>
<!--            <xs:element ref="f:colon"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statement"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="enhancedForStatementNoShortIf" type="f:enhancedForStatementNoShortIf"/>
    <xs:complexType name="enhancedForStatementNoShortIf">
        <xs:sequence>
<!--            <xs:element ref="f:for"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclaratorId"/>
<!--            <xs:element ref="f:colon"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:statementNoShortIf"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="breakStatement" type="f:breakStatement"/>
    <xs:complexType name="breakStatement">
        <xs:sequence>
<!--            <xs:element ref="f:break"/>-->
            <xs:element ref="f:identifier" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="continueStatement" type="f:continueStatement"/>
    <xs:complexType name="continueStatement">
        <xs:sequence>
<!--            <xs:element ref="f:continue"/>-->
            <xs:element ref="f:identifier" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="returnStatement" type="f:returnStatement"/>
    <xs:complexType name="returnStatement">
        <xs:sequence>
<!--            <xs:element ref="f:return"/>-->
            <xs:element ref="f:expression" minOccurs="0"/>
<!--            <xs:element ref="f:semicolon"/>-->
        </xs:sequence>
    </xs:complexType>

<!--    <xs:element name="throwStatement" type="f:throwStatement"/>-->
<!--    <xs:complexType name="throwStatement">-->
<!--        <xs:sequence>-->
<!--            <xs:element ref="f:throw"/>-->
<!--            <xs:element ref="f:expression"/>-->
<!--&lt;!&ndash;            <xs:element ref="f:semicolon"/>&ndash;&gt;-->
<!--        </xs:sequence>-->
<!--    </xs:complexType>-->

    <xs:element name="synchronizedStatement" type="f:synchronizedStatement"/>
    <xs:complexType name="synchronizedStatement">
        <xs:sequence>
<!--            <xs:element ref="f:synchronized"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:block"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="tryStatement" type="f:tryStatement"/>
    <xs:complexType name="tryStatement">
        <xs:choice>
            <xs:sequence>
<!--                <xs:element ref="f:try"/>-->
                <xs:element ref="f:block"/>
                <xs:element ref="f:catches" minOccurs="0"/>
                <xs:element ref="f:finally" minOccurs="0"/>
            </xs:sequence>
            <xs:element ref="f:tryWithResourcesStatement"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="catches" type="f:catches"/>
    <xs:complexType name="catches">
        <xs:sequence>
            <xs:element ref="f:catchClause"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="f:catchClause"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="catchClause" type="f:catchClause"/>
    <xs:complexType name="catchClause">
        <xs:sequence>
<!--            <xs:element ref="f:catch"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:catchFormalParameter"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:block"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="catchFormalParameter" type="f:catchFormalParameter"/>
    <xs:complexType name="catchFormalParameter">
        <xs:sequence>
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:catchType"/>
            <xs:element ref="f:variableDeclaratorId"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="catchType" type="f:catchType"/>
    <xs:complexType name="catchType">
        <xs:sequence>
            <xs:element ref="f:unannClassType"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
<!--                <xs:element ref="f:pipe"/>-->
                <xs:element ref="f:unannClassType"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="finally" type="f:finally"/>
    <xs:complexType name="finally">
        <xs:sequence>
            <xs:element ref="f:finally"/>
            <xs:element ref="f:block"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="tryWithResourcesStatement" type="f:tryWithResourcesStatement"/>
    <xs:complexType name="tryWithResourcesStatement">
        <xs:sequence>
<!--            <xs:element ref="f:try"/>-->
<!--            <xs:element ref="f:leftParen"/>-->
            <xs:element ref="f:resourceSpecification"/>
<!--            <xs:element ref="f:rightParen"/>-->
            <xs:element ref="f:block"/>
            <xs:element ref="f:catches" minOccurs="0"/>
            <xs:element ref="f:finally" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="resourceSpecification" type="f:resourceSpecification"/>
    <xs:complexType name="resourceSpecification">
        <xs:sequence>
            <xs:element ref="f:resourceList"/>
            <xs:sequence minOccurs="0">
<!--                <xs:element ref="f:semicolon"/>-->
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="resourceList" type="f:resourceList"/>
    <xs:complexType name="resourceList">
        <xs:sequence>
            <xs:element ref="f:resource"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
<!--                <xs:element ref="f:semicolon"/>-->
                <xs:element ref="f:resource"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="resource" type="f:resource"/>
    <xs:complexType name="resource">
        <xs:sequence>
            <xs:element ref="f:variableModifier" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="f:unannType"/>
            <xs:element ref="f:variableDeclaratorId"/>
<!--            <xs:element ref="f:equals"/>-->
            <xs:element ref="f:expression"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="primary" type="f:primary"/>
    <xs:complexType name="primary">
        <xs:choice>
            <xs:element ref="f:primaryNoNewArray"/>
            <xs:element ref="f:arrayCreationExpression"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="primaryNoNewArray" type="f:primaryNoNewArray"/>
    <xs:complexType name="primaryNoNewArray">
        <xs:choice>
            <xs:element ref="f:literal"/>
            <xs:element ref="f:classLiteral"/>
            <xs:element ref="f:this"/>
            <xs:sequence>
                <xs:element ref="f:typeName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:this"/>
            </xs:sequence>
            <xs:sequence>
<!--                <xs:element ref="f:leftParen"/>-->
                <xs:element ref="f:expression"/>
<!--                <xs:element ref="f:rightParen"/>-->
            </xs:sequence>
            <xs:element ref="f:classInstanceCreationExpression"/>
            <xs:element ref="f:fieldAccess"/>
            <xs:element ref="f:arrayAccess"/>
            <xs:element ref="f:methodInvocation"/>
            <xs:element ref="f:methodReference"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="classLiteral" type="f:classLiteral"/>
    <xs:complexType name="classLiteral">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
<!--        <xs:choice>-->
<!--            <xs:sequence>-->
<!--                <xs:element ref="f:typeName"/>-->
<!--&lt;!&ndash;                <xs:element ref="f:squareBrackets" minOccurs="0" maxOccurs="unbounded"/>&ndash;&gt;-->
<!--&lt;!&ndash;                <xs:element ref="f:dot"/>&ndash;&gt;-->
<!--&lt;!&ndash;                <xs:element ref="f:class"/>&ndash;&gt;-->
<!--            </xs:sequence>-->

<!--            <xs:sequence>-->
<!--                <xs:element ref="f:numericType"/>-->
<!--                <xs:element ref="f:squareBrackets" minOccurs="0" maxOccurs="unbounded"/>-->
<!--                <xs:element ref="f:dot"/>-->
<!--                <xs:element ref="f:class"/>-->
<!--            </xs:sequence>-->

<!--            <xs:sequence>-->
<!--                <xs:element ref="f:boolean"/>-->
<!--                <xs:element ref="f:squareBrackets" minOccurs="0" maxOccurs="unbounded"/>-->
<!--                <xs:element ref="f:dot"/>-->
<!--                <xs:element ref="f:class"/>-->
<!--            </xs:sequence>-->

<!--            <xs:sequence>-->
<!--                <xs:element ref="f:void"/>-->
<!--                <xs:element ref="f:dot"/>-->
<!--                <xs:element ref="f:class"/>-->
<!--            </xs:sequence>-->

<!--        </xs:choice>-->
    </xs:complexType>

    <xs:element name="classInstanceCreationExpression" type="f:classInstanceCreationExpression"/>
    <xs:complexType name="classInstanceCreationExpression">
        <xs:choice>
            <xs:element ref="f:unqualifiedClassInstanceCreationExpression"/>

            <xs:sequence>
                <xs:element ref="f:expressionName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:unqualifiedClassInstanceCreationExpression"/>
            </xs:sequence>

            <xs:sequence>
                <xs:element ref="f:primary"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:unqualifiedClassInstanceCreationExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="unqualifiedClassInstanceCreationExpression" type="f:unqualifiedClassInstanceCreationExpression"/>
    <xs:complexType name="unqualifiedClassInstanceCreationExpression">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:new"/>
<!--                <xs:element ref="f:typeArguments" minOccurs="0"/>-->
                <xs:element ref="f:classOrInterfaceTypeToInstantiate"/>
                <xs:element ref="f:argumentList" minOccurs="0"/>
            </xs:sequence>
            <xs:element ref="f:classBodyDeclaration"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="classOrInterfaceTypeToInstantiate" type="f:classOrInterfaceTypeToInstantiate"/>
    <xs:complexType name="classOrInterfaceTypeToInstantiate">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
<!--                <xs:element ref="f:typeArgumentsOrDiamond"/>-->
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="fieldAccess" type="f:fieldAccess"/>
    <xs:complexType name="fieldAccess">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:primary"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:super"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:typeName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:super"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="typeName" type="f:typeName"/>
    <xs:complexType name="typeName">
        <xs:choice>
            <xs:element ref="f:identifier"/>
            <xs:sequence>
                <xs:element ref="f:packageOrTypeName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="packageOrTypeName" type="f:packageOrTypeName"/>
    <xs:complexType name="packageOrTypeName">
        <xs:choice>
            <xs:element ref="f:identifier"/>
            <xs:sequence>
                <xs:element ref="f:packageOrTypeName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="arrayAccess" type="f:arrayAccess"/>
    <xs:complexType name="arrayAccess">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:expressionName"/>
<!--                <xs:element ref="f:leftBracket"/>-->
                <xs:element ref="f:expression"/>
<!--                <xs:element ref="f:rightBracket"/>-->
            </xs:sequence>
            <xs:sequence>
<!--                <xs:element ref="f:primaryNoNewArray"/>-->
<!--                <xs:element ref="f:leftBracket"/>-->
                <xs:element ref="f:expression"/>
<!--                <xs:element ref="f:rightBracket"/>-->
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="methodInvocation" type="f:methodInvocation"/>
    <xs:complexType name="methodInvocation">
        <xs:sequence>

            <xs:choice>

                <xs:sequence>
                    <xs:element ref="f:methodName"/>
<!--                    <xs:element ref="f:leftParen"/>-->
                    <xs:element ref="f:argumentList" minOccurs="0"/>
<!--                    <xs:element ref="f:rightParen"/>-->
                </xs:sequence>

                <xs:sequence>
                    <xs:choice>

                        <xs:sequence>
                            <xs:element ref="f:typeName"/>
                            <xs:sequence minOccurs="0">
<!--                                <xs:element ref="f:dot"/>-->
                                <xs:element ref="f:super"/>
<!--                                <xs:element ref="f:dot"/>-->
                            </xs:sequence>
                        </xs:sequence>

                        <xs:element ref="f:expressionName"/>
                        <xs:element ref="f:primary"/>
                        <xs:element ref="f:super"/>

                    </xs:choice>

                    <xs:sequence>
<!--                        <xs:element ref="f:typeArguments" minOccurs="0"/>-->
                        <xs:element ref="f:identifier"/>
<!--                        <xs:element ref="f:leftParen"/>-->
                        <xs:element ref="f:argumentList" minOccurs="0"/>
<!--                        <xs:element ref="f:rightParen"/>-->
                    </xs:sequence>
                </xs:sequence>

            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="methodName" type="f:methodName"/>
    <xs:complexType name="methodName">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="argumentList" type="f:argumentList"/>
    <xs:complexType name="argumentList">
        <xs:sequence>
            <xs:element ref="f:expression" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="methodReference" type="f:methodReference"/>
    <xs:complexType name="methodReference">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="arrayCreationExpression" type="f:arrayCreationExpression"/>
    <xs:complexType name="arrayCreationExpression">
        <xs:sequence>
            <xs:element ref="f:new"/>
            <xs:choice>

                <xs:sequence>

                    <xs:element ref="f:primitiveType"/>

                    <xs:choice>
                        <xs:sequence>
                            <xs:element ref="f:dimExprs"/>
                            <xs:element ref="f:dims" minOccurs="0"/>
                        </xs:sequence>
                        <xs:sequence>
                            <xs:element ref="f:dims"/>
                            <xs:element ref="f:arrayInitializer"/>
                        </xs:sequence>
                    </xs:choice>


                </xs:sequence>


                <xs:sequence>

                    <xs:element ref="f:classOrInterfaceType"/>

                    <xs:choice>
                        <xs:sequence>
                            <xs:element ref="f:dimExprs"/>
                            <xs:element ref="f:dims" minOccurs="0"/>
                        </xs:sequence>

                        <xs:sequence>
                            <xs:element ref="f:dims"/>
                            <xs:element ref="f:arrayInitializer"/>
                        </xs:sequence>

                    </xs:choice>


                </xs:sequence>


            </xs:choice>
        </xs:sequence>

    </xs:complexType>

    <xs:element name="dimExprs" type="f:dimExprs"/>
    <xs:complexType name="dimExprs">
        <xs:sequence>
            <xs:element ref="f:dimExpr" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="dimExpr" type="f:dimExpr"/>
    <xs:complexType name="dimExpr">
        <xs:sequence>
<!--            <xs:element ref="f:leftBracket"/>-->
            <xs:element ref="f:expression"/>
<!--            <xs:element ref="f:rightBracket"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="expression" type="f:expression"/>
    <xs:complexType name="expression">
        <xs:sequence>
            <xs:element ref="f:assignmentExpression"/>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="assignmentExpression" type="f:assignmentExpression"/>
    <xs:complexType name="assignmentExpression">
        <xs:choice>
            <xs:element ref="f:conditionalExpression"/>
            <xs:element ref="f:assignment"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="assignment" type="f:assignment"/>
    <xs:complexType name="assignment">
        <xs:sequence>
            <xs:element ref="f:leftHandSide"/>
            <xs:element ref="f:assignmentOperator"/>
            <xs:element ref="f:expression"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="leftHandSide" type="f:leftHandSide"/>
    <xs:complexType name="leftHandSide">
        <xs:choice>
            <xs:element ref="f:expressionName"/>
            <xs:element ref="f:fieldAccess"/>
            <xs:element ref="f:arrayAccess"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="conditionalExpression" type="f:conditionalExpression"/>
    <xs:complexType name="conditionalExpression">

        <xs:sequence>
            <xs:element ref="f:conditionalOrExpression"/>

<!--            <xs:sequence minOccurs="0">-->
<!--                <xs:sequence>-->
<!--&lt;!&ndash;                    <xs:element ref="f:questionMark"/>&ndash;&gt;-->
<!--                    <xs:element ref="f:expression"/>-->
<!--&lt;!&ndash;                    <xs:element ref="f:colon"/>&ndash;&gt;-->
<!--                    <xs:choice>-->
<!--                        <xs:element ref="f:conditionalOrExpression"/>-->

<!--                    </xs:choice>-->
<!--                </xs:sequence>-->
<!--            </xs:sequence>-->

        </xs:sequence>
    </xs:complexType>

    <xs:element name="conditionalOrExpression" type="f:conditionalOrExpression"/>
    <xs:complexType name="conditionalOrExpression">
        <xs:choice>
            <xs:element ref="f:conditionalAndExpression"/>
            <xs:sequence>
                <xs:element ref="f:conditionalOrExpression"/>
<!--                <xs:element ref="f:doublePipe"/>-->
                <xs:element ref="f:conditionalAndExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="conditionalAndExpression" type="f:conditionalAndExpression"/>
    <xs:complexType name="conditionalAndExpression">
        <xs:choice>
            <xs:element ref="f:inclusiveOrExpression"/>
            <xs:sequence>
                <xs:element ref="f:conditionalAndExpression"/>
<!--                <xs:element ref="f:doubleAmpersand"/>-->
                <xs:element ref="f:inclusiveOrExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="inclusiveOrExpression" type="f:inclusiveOrExpression"/>
    <xs:complexType name="inclusiveOrExpression">
        <xs:choice>
            <xs:element ref="f:exclusiveOrExpression"/>
            <xs:sequence>
                <xs:element ref="f:inclusiveOrExpression"/>
<!--                <xs:element ref="f:pipe"/>-->
                <xs:element ref="f:exclusiveOrExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="exclusiveOrExpression" type="f:exclusiveOrExpression"/>
    <xs:complexType name="exclusiveOrExpression">
        <xs:choice>
            <xs:element ref="f:andExpression"/>
            <xs:sequence>
                <xs:element ref="f:exclusiveOrExpression"/>
<!--                <xs:element ref="f:hat"/>-->
                <xs:element ref="f:andExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="andExpression" type="f:andExpression"/>
    <xs:complexType name="andExpression">
        <xs:choice>
            <xs:element ref="f:equalityExpression"/>
            <xs:sequence>
                <xs:element ref="f:andExpression"/>
<!--                <xs:element ref="f:ampersand"/>-->
                <xs:element ref="f:equalityExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="equalityExpression" type="f:equalityExpression"/>
    <xs:complexType name="equalityExpression">
        <xs:choice>
            <xs:element ref="f:relationalExpression"/>
            <xs:sequence>
                <xs:element ref="f:equalityExpression"/>
                <xs:choice>
                    <xs:sequence>
<!--                        <xs:element ref="f:equalsEquals"/>-->
                        <xs:element ref="f:relationalExpression"/>
                    </xs:sequence>
                    <xs:sequence>
<!--                        <xs:element ref="f:exclamationMarkEquals"/>-->
                        <xs:element ref="f:relationalExpression"/>
                    </xs:sequence>
                </xs:choice>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="relationalExpression" type="f:relationalExpression"/>
    <xs:complexType name="relationalExpression">
        <xs:choice>
            <xs:element ref="f:shiftExpression"/>
            <xs:sequence>
                <xs:element ref="f:relationalExpression"/>
                <xs:choice>
                    <xs:element ref="f:lessThan"/>
                    <xs:element ref="f:greaterThan"/>
                    <xs:element ref="f:lessThanEquals"/>
                    <xs:element ref="f:greaterThanEquals"/>
                    <xs:element ref="f:instanceof"/>
                </xs:choice>
                <xs:element ref="f:shiftExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="shiftExpression" type="f:shiftExpression"/>
    <xs:complexType name="shiftExpression">
        <xs:choice>
            <xs:element ref="f:additiveExpression"/>
            <xs:sequence>
                <xs:element ref="f:shiftExpression"/>
                <xs:choice>
                    <xs:element ref="f:lessThanLessThan"/>
                    <xs:element ref="f:moreThanMoreThan"/>
                    <xs:element ref="f:moreThanMoreThanMoreThan"/>
                </xs:choice>
                <xs:element ref="f:additiveExpression"/>
            </xs:sequence>

        </xs:choice>
    </xs:complexType>

    <xs:element name="additiveExpression" type="f:additiveExpression"/>
    <xs:complexType name="additiveExpression">
        <xs:choice>
            <xs:element ref="f:multiplicativeExpression"/>
            <xs:sequence>
                <xs:element ref="f:additiveExpression"/>
                <xs:choice>
                    <xs:element ref="f:plus"/>
                    <xs:element ref="f:minus"/>
                </xs:choice>
                <xs:element ref="f:multiplicativeExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="multiplicativeExpression" type="f:multiplicativeExpression"/>
    <xs:complexType name="multiplicativeExpression">
        <xs:choice>
            <xs:element ref="f:unaryExpression"/>
            <xs:sequence>
                <xs:element ref="f:multiplicativeExpression"/>
                <xs:choice>
                    <xs:element ref="f:star"/>
                    <xs:element ref="f:forwardSlash"/>
                    <xs:element ref="f:percent"/>
                </xs:choice>
                <xs:element ref="f:unaryExpression"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>


    <xs:element name="unaryExpression" type="f:unaryExpression"/>
    <xs:complexType name="unaryExpression">
        <xs:choice>
            <xs:element ref="f:preIncrementExpression"/>
            <xs:element ref="f:preDecrementExpression"/>
            <xs:choice>
                <xs:sequence>
                    <xs:element ref="f:plusPlus"/>
                    <xs:element ref="f:unaryExpression"/>
                </xs:sequence>
                <xs:sequence>

                </xs:sequence>
            </xs:choice>
            <xs:element ref="f:unaryExpressionNotPlusMinus"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="preIncrementExpression" type="f:preIncrementExpression"/>
    <xs:complexType name="preIncrementExpression">
        <xs:sequence>
            <xs:element ref="f:plusPlus"/>
            <xs:element ref="f:unaryExpression"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="preDecrementExpression" type="f:preDecrementExpression"/>
    <xs:complexType name="preDecrementExpression">
        <xs:sequence>
            <xs:element ref="f:minusMinus"/>
            <xs:element ref="f:unaryExpression"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="unaryExpressionNotPlusMinus" type="f:unaryExpressionNotPlusMinus"/>
    <xs:complexType name="unaryExpressionNotPlusMinus">
        <xs:choice>
            <xs:element ref="f:postfixExpression"/>
            <xs:sequence>
                <xs:element ref="f:tilde"/>
                <xs:element ref="f:unaryExpression"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:exclamationMark"/>
                <xs:element ref="f:unaryExpression"/>
            </xs:sequence>
            <xs:element ref="f:castExpression"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="postfixExpression" type="f:postfixExpression"/>
    <xs:complexType name="postfixExpression">
        <xs:choice>
            <xs:element ref="f:primary"/>
            <xs:element ref="f:expressionName"/>
            <xs:element ref="f:postIncrementExpression"/>
            <xs:element ref="f:postDecrementExpression"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="expressionName" type="f:expressionName"/>
    <xs:complexType name="expressionName">
        <xs:choice>
            <xs:element ref="f:identifier"/>
            <xs:sequence>
                <xs:element ref="f:ambiguousName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="ambiguousName" type="f:ambiguousName"/>
    <xs:complexType name="ambiguousName">
        <xs:choice>
            <xs:element ref="f:identifier"/>
            <xs:sequence>
                <xs:element ref="f:ambiguousName"/>
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="postIncrementExpression" type="f:postIncrementExpression"/>
    <xs:complexType name="postIncrementExpression">
        <xs:sequence>
            <xs:element ref="f:postfixExpression"/>
<!--            <xs:element ref="f:plusPlus"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="postDecrementExpression" type="f:postDecrementExpression"/>
    <xs:complexType name="postDecrementExpression">
        <xs:sequence>
            <xs:element ref="f:postfixExpression"/>
<!--            <xs:element ref="f:minusMinus"/>-->
        </xs:sequence>
    </xs:complexType>

    <xs:element name="castExpression" type="f:castExpression"/>
    <xs:complexType name="castExpression">
        <xs:sequence>
<!--            <xs:element ref="f:leftParen"/>-->

            <xs:choice>
                <xs:sequence>

                    <xs:element ref="f:primitiveType"/>
<!--                    <xs:element ref="f:rightParen"/>-->
                    <xs:element ref="f:unaryExpression"/>
                </xs:sequence>

                <xs:sequence>

                    <xs:element ref="f:referenceType"/>
<!--                    <xs:element ref="f:additionalBound" minOccurs="0" maxOccurs="unbounded"/>-->
<!--                    <xs:element ref="f:rightParen"/>-->

                    <xs:choice>
                        <xs:element ref="f:unaryExpressionNotPlusMinus"/>
<!--                        <xs:element ref="f:lambdaExpression"/>-->
                    </xs:choice>


                </xs:sequence>

            </xs:choice>

        </xs:sequence>

    </xs:complexType>

    <xs:element name="constantExpression" type="f:constantExpression"/>
    <xs:complexType name="constantExpression">
        <xs:sequence>
            <xs:element ref="f:expression"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="referenceType" type="f:referenceType"/>
    <xs:complexType name="referenceType">
        <xs:choice>
            <xs:element ref="f:classOrInterfaceType"/>
            <xs:element ref="f:typeVariable"/>
            <xs:element ref="f:arrayType"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="classOrInterfaceType" type="f:classOrInterfaceType"/>
    <xs:complexType name="classOrInterfaceType">
        <xs:choice>
            <xs:element ref="f:classType"/>
            <xs:element ref="f:interfaceType"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="classType" type="f:classType"/>
    <xs:complexType name="classType">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="interfaceType" type="f:interfaceType"/>
    <xs:complexType name="interfaceType">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="typeVariable" type="f:typeVariable"/>
    <xs:complexType name="typeVariable">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="arrayType" type="f:arrayType"/>
    <xs:complexType name="arrayType">
        <xs:choice>
            <xs:sequence>
                <xs:element ref="f:primitiveType"/>
                <xs:element ref="f:dims"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:classOrInterfaceType"/>
                <xs:element ref="f:dims"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="f:typeVariable"/>
                <xs:element ref="f:dims"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

    <xs:element name="dims" type="f:dims"/>
    <xs:complexType name="dims">
        <xs:sequence>
            <xs:element ref="f:dim" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="dim" type="f:dim"/>
    <xs:simpleType name="dim">
        <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>



    <xs:element name="primitiveType" type="f:primitiveType"/>
    <xs:complexType name="primitiveType">
        <xs:choice>
            <xs:element ref="f:numericType"/>
            <xs:element ref="f:boolean"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="numericType" type="f:numericType"/>
    <xs:complexType name="numericType">
        <xs:choice>
            <xs:element ref="f:int"/>
            <xs:element ref="f:long"/>
            <xs:element ref="f:short"/>
            <xs:element ref="f:byte"/>
            <xs:element ref="f:char"/>
            <xs:element ref="f:float"/>
            <xs:element ref="f:double"/>
        </xs:choice>
    </xs:complexType>




    <xs:element name="dot" type="xs:string" fixed="."/>
<!--    <xs:element name="comma" type="xs:string" fixed=","/>-->
<!--    <xs:element name="semicolon" type="xs:string" fixed=";"/>-->
<!--    <xs:element name="colon" type="xs:string" fixed=":"/>-->
<!--    <xs:element name="questionMark" type="xs:string" fixed="?"/>-->
<!--    <xs:element name="leftParen" type="xs:string" fixed="("/>-->
<!--    <xs:element name="rightParen" type="xs:string" fixed=")"/>-->
<!--    <xs:element name="leftBrace" type="xs:string" fixed="{"/>-->
<!--    <xs:element name="rightBrace" type="xs:string" fixed="}"/>-->
<!--    <xs:element name="leftBracket" type="xs:string" fixed="["/>-->
<!--    <xs:element name="rightBracket" type="xs:string" fixed="]"/>-->
<!--    <xs:element name="at" type="xs:string" fixed="@"/>-->
    <xs:element name="ellipsis" type="xs:string" fixed="..."/>
    <xs:element name="lessThan" type="xs:string" fixed="&lt;"/>
    <xs:element name="greaterThan" type="xs:string" fixed=">"/>
    <xs:element name="equals" type="xs:string" fixed="="/>
    <xs:element name="star" type="xs:string" fixed="*"/>
    <xs:element name="rightArrow" type="xs:string" fixed="->"/>
    <xs:element name="pipe" type="xs:string" fixed="|"/>
    <xs:element name="doublePipe" type="xs:string" fixed="||"/>
    <xs:element name="doubleColon" type="xs:string" fixed="::"/>
    <xs:element name="percent" type="xs:string" fixed="%"/>
    <xs:element name="forwardSlash" type="xs:string" fixed="/"/>
    <xs:element name="lessThanLessThan" type="xs:string" fixed="&lt;&lt;"/>
    <xs:element name="moreThanMoreThan" type="xs:string" fixed="&gt;&gt;"/>
    <xs:element name="moreThanMoreThanMoreThan" type="xs:string" fixed="&gt;&gt;&gt;"/>
    <xs:element name="plusPlus" type="xs:string" fixed="++"/>
    <xs:element name="plus" type="xs:string" fixed="+"/>
    <xs:element name="minus" type="xs:string" fixed="-"/>
    <xs:element name="minusMinus" type="xs:string" fixed="--"/>
    <xs:element name="diamond" type="xs:string" fixed="&lt;>"/>
    <xs:element name="exclamationMark" type="xs:string" fixed="!"/>
    <xs:element name="tilde" type="xs:string" fixed="~"/>

    <xs:element name="lessThanEquals" type="xs:string" fixed="&lt;="/>
    <xs:element name="greaterThanEquals" type="xs:string" fixed=">="/>
    <xs:element name="equalsEquals" type="xs:string" fixed="=="/>
    <xs:element name="exclamationMarkEquals" type="xs:string" fixed="!="/>

    <xs:element name="hat" type="xs:string" fixed="^"/>
    <xs:element name="ampersand" type="xs:string" fixed="&amp;"/>
    <xs:element name="doubleAmpersand" type="xs:string" fixed="&amp;&amp;"/>
    <xs:element name="squareBrackets" type="xs:string" fixed="[]"/>
    <xs:element name="diamondBrackets" type="xs:string" fixed="&lt;>"/>


    <xs:element name="infixOperator" type="f:infixOperator"/>
    <xs:complexType name="infixOperator">
        <xs:sequence>
            <xs:choice>
                <xs:element name="add" type="xs:string" fixed="+"/>

                <xs:element name="sub" type="xs:string" fixed="-"/>
                <xs:element name="mul" type="xs:string" fixed="*"/>
                <xs:element name="div" type="xs:string" fixed="/"/>
                <xs:element name="mod" type="xs:string" fixed="%"/>
                <xs:element name="and" type="xs:string" fixed="&amp;"/>
                <xs:element name="or" type="xs:string" fixed="|"/>
                <xs:element name="xor" type="xs:string" fixed="^"/>
                <xs:element name="leftShift" type="xs:string" fixed="&lt;&lt;"/>
                <xs:element name="rightShift" type="xs:string" fixed="&gt;&gt;"/>
                <xs:element name="unsignedRightShift" type="xs:string" fixed="&gt;&gt;&gt;"/>
                <xs:element name="lessThan" type="xs:string" fixed="&lt;"/>
                <xs:element name="greaterThan" type="xs:string" fixed="&gt;"/>
                <xs:element name="lessThanOrEqual" type="xs:string" fixed="&lt;="/>
                <xs:element name="greaterThanOrEqual" type="xs:string" fixed="&gt;="/>
                <xs:element name="equal" type="xs:string" fixed="=="/>
                <xs:element name="notEqual" type="xs:string" fixed="!="/>
                <xs:element name="andBool" type="xs:string" fixed="&amp;&amp;"/>
                <xs:element name="orBool" type="xs:string" fixed="||"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>


    <xs:element name="prefixOperator" type="f:prefixOperator"/>
    <xs:complexType name="prefixOperator">
        <xs:sequence>
            <xs:choice>
                <xs:element name="inc" type="xs:string" fixed="++"/>
                <xs:element name="dec" type="xs:string" fixed="--"/>
                <xs:element name="not" type="xs:string" fixed="!"/>
                <xs:element name="neg" type="xs:string" fixed="-"/>
                <xs:element name="pos" type="xs:string" fixed="+"/>
                <xs:element name="complement" type="xs:string" fixed="~"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="postfixOperator" type="f:postfixOperator"/> <!-- TODO: Add postfixOperator to expression3 -->
    <xs:complexType name="postfixOperator">
        <xs:sequence>
            <xs:choice>
                <xs:element name="inc" type="xs:string" fixed="++"/>
                <xs:element name="dec" type="xs:string" fixed="--"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="assignmentOperator" type="f:assignmentOperator"/>
    <xs:complexType name="assignmentOperator">
        <xs:sequence>
            <xs:choice>
                <xs:element name="assign" type="xs:string" fixed="="/>
                <xs:element name="addAssign" type="xs:string" fixed="+="/>
                <xs:element name="subAssign" type="xs:string" fixed="-="/>
                <xs:element name="mulAssign" type="xs:string" fixed="*="/>
                <xs:element name="divAssign" type="xs:string" fixed="/="/>
                <xs:element name="modAssign" type="xs:string" fixed="%="/>
                <xs:element name="andAssign" type="xs:string" fixed="&amp;="/>
                <xs:element name="orAssign" type="xs:string" fixed="|="/>
                <xs:element name="xorAssign" type="xs:string" fixed="^="/>
                <xs:element name="leftShiftAssign" type="xs:string" fixed="&lt;&lt;="/>
                <xs:element name="rightShiftAssign" type="xs:string" fixed=">>="/>
                <xs:element name="unsignedRightShiftAssign" type="xs:string" fixed=">>>="/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="literal" type="f:literal"/>
    <xs:complexType name="literal">
        <xs:choice>
            <xs:element name="integerLiteral" type="xs:string"/>
            <xs:element name="floatingPointLiteral" type="xs:string"/>
            <xs:element name="booleanLiteral" type="xs:string"/>
            <xs:element name="characterLiteral" type="xs:string"/>
            <xs:element name="stringLiteral" type="xs:string"/>
            <xs:element name="nullLiteral" type="xs:string"/>
        </xs:choice>
    </xs:complexType>


    <xs:complexType name="integerLiteral">
        <xs:sequence>
            <xs:element name="decimalIntegerLiteral" type="xs:string"/>
            <xs:element name="hexIntegerLiteral" type="xs:string"/>
            <xs:element name="octalIntegerLiteral" type="xs:string"/>
            <xs:element name="binaryIntegerLiteral" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>


<!--    <xs:element name="abstract" type="xs:string" fixed="abstract"/>-->
<!--    <xs:element name="assert" type="xs:string" fixed="assert"/>-->
<!--    <xs:element name="boolean" type="xs:string" fixed="boolean"/>-->
<!--    <xs:element name="break" type="xs:string" fixed="break"/>-->
<!--    <xs:element name="byte" type="xs:string" fixed="byte"/>-->
<!--    <xs:element name="case" type="xs:string" fixed="case"/>-->
<!--    <xs:element name="catch" type="xs:string" fixed="catch"/>-->
<!--    <xs:element name="char" type="xs:string" fixed="char"/>-->
<!--    <xs:element name="class" type="xs:string" fixed="class"/>-->
<!--    <xs:element name="const" type="xs:string" fixed="const"/>-->
<!--    <xs:element name="continue" type="xs:string" fixed="continue"/>-->
<!--    <xs:element name="default" type="xs:string" fixed="default"/>-->
<!--    <xs:element name="do" type="xs:string" fixed="do"/>-->
<!--    <xs:element name="double" type="xs:string" fixed="double"/>-->
<!--    <xs:element name="else" type="xs:string" fixed="else"/>-->
<!--    <xs:element name="enum" type="xs:string" fixed="enum"/>-->
<!--    <xs:element name="extends" type="xs:string" fixed="extends"/>-->
<!--    <xs:element name="final" type="xs:string" fixed="final"/>-->
<!--    <xs:element name="float" type="xs:string" fixed="float"/>-->
<!--    <xs:element name="for" type="xs:string" fixed="for"/>-->
<!--    <xs:element name="goto" type="xs:string" fixed="goto"/>-->
<!--    <xs:element name="if" type="xs:string" fixed="if"/>-->

<!--    <xs:element name="implements" type="xs:string" fixed="implements"/>-->
<!--    <xs:element name="import" type="xs:string" fixed="import"/>-->
    <xs:element name="instanceof" type="xs:string" fixed="instanceof"/>
<!--    <xs:element name="int" type="xs:string" fixed="int"/>-->
<!--    <xs:element name="interface" type="xs:string" fixed="interface"/>-->
<!--    <xs:element name="long" type="xs:string" fixed="long"/>-->
<!--    <xs:element name="native" type="xs:string" fixed="native"/>-->
<!--    <xs:element name="new" type="xs:string" fixed="new"/>-->
<!--    <xs:element name="null" type="xs:string" fixed="null"/>-->
<!--    <xs:element name="package" type="xs:string" fixed="package"/>-->
<!--    <xs:element name="private" type="xs:string" fixed="private"/>-->
<!--    <xs:element name="protected" type="xs:string" fixed="protected"/>-->
<!--    <xs:element name="public" type="xs:string" fixed="public"/>-->
<!--    <xs:element name="return" type="xs:string" fixed="return"/>-->
<!--    <xs:element name="short" type="xs:string" fixed="short"/>-->
<!--    <xs:element name="static" type="xs:string" fixed="static"/>-->
<!--    <xs:element name="strictfp" type="xs:string" fixed="strictfp"/>-->
<!--    <xs:element name="super" type="xs:string" fixed="super"/>-->
<!--    <xs:element name="switch" type="xs:string" fixed="switch"/>-->
<!--    <xs:element name="synchronized" type="xs:string" fixed="synchronized"/>-->
<!--    <xs:element name="this" type="xs:string" fixed="this"/>-->
<!--    <xs:element name="throw" type="xs:string" fixed="throw"/>-->
<!--    <xs:element name="transient" type="xs:string" fixed="transient"/>-->
<!--    <xs:element name="try" type="xs:string" fixed="try"/>-->
<!--    <xs:element name="void" type="xs:string" fixed="void"/>-->
<!--    <xs:element name="volatile" type="xs:string" fixed="volatile"/>-->
<!--    <xs:element name="while" type="xs:string" fixed="while"/>-->

    <xs:element name="identifier" type="f:identifier"/>
    <xs:simpleType name="identifier">
        <xs:restriction base="xs:string">
            <xs:maxLength value="256"/>
            <xs:pattern value="[a-zA-Z_][a-zA-Z0-9_]*"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="qualifiedIdentifier" type="f:qualifiedIdentifier"/>
    <xs:complexType name="qualifiedIdentifier">
        <xs:sequence>
            <xs:element ref="f:identifier"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="f:dot"/>
                <xs:element ref="f:identifier"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="qualifiedIdentifierList" type="f:qualifiedIdentifierList"/>
    <xs:complexType name="qualifiedIdentifierList">
        <xs:sequence>
            <xs:element ref="f:qualifiedIdentifier"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="comma" type="xs:string" fixed=","/>
                <xs:element ref="f:qualifiedIdentifier"/>
            </xs:sequence>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="modifiers" type="f:modifiers"/>
    <xs:complexType name="modifiers">
        <xs:choice>
            <xs:element name="public" type="xs:string" fixed="public"/>
            <xs:element name="protected" type="xs:string" fixed="protected"/>
            <xs:element name="private" type="xs:string" fixed="private"/>
            <xs:element name="static" type="xs:string" fixed="static"/>
            <xs:element name="abstract" type="xs:string" fixed="abstract"/>
            <xs:element name="final" type="xs:string" fixed="final"/>
            <xs:element name="native" type="xs:string" fixed="native"/>
            <xs:element name="synchronized" type="xs:string" fixed="synchronized"/>
            <xs:element name="transient" type="xs:string" fixed="transient"/>
            <xs:element name="volatile" type="xs:string" fixed="volatile"/>
            <xs:element name="strictfp" type="xs:string" fixed="strictfp"/>
        </xs:choice>
    </xs:complexType>

    <xs:element name="int" type="f:int"/>
    <xs:simpleType name="int">
        <xs:restriction base="xs:integer">
            <xs:minInclusive value="-2147483648"/>
            <xs:maxInclusive value="2147483647"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="long" type="f:long"/>
    <xs:simpleType name="long">
        <xs:restriction base="xs:integer">
            <xs:minInclusive value="-9223372036854775808"/>
            <xs:maxInclusive value="9223372036854775807"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="float" type="f:float"/>
    <xs:simpleType name="float">
        <xs:restriction base="xs:float"/>
    </xs:simpleType>

    <xs:element name="double" type="f:double"/>
    <xs:simpleType name="double">
        <xs:restriction base="xs:double"/>
    </xs:simpleType>

    <xs:element name="boolean" type="f:boolean"/>
    <xs:simpleType name="boolean">
        <xs:restriction base="xs:boolean"/>
    </xs:simpleType>

    <xs:element name="char" type="f:char"/>
    <xs:simpleType name="char">
        <xs:restriction base="xs:string">
            <xs:length value="1"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="byte" type="f:byte"/>
    <xs:simpleType name="byte">
        <xs:restriction base="xs:byte"/>
    </xs:simpleType>

    <xs:element name="short" type="f:short"/>
    <xs:simpleType name="short">
        <xs:restriction base="xs:short"/>
    </xs:simpleType>

    <xs:element name="string" type="f:string"/>
    <xs:simpleType name="string">
        <xs:restriction base="xs:string"/>
    </xs:simpleType>

<xs:element name="void" type="f:void"/>
    <xs:simpleType name="void">
        <xs:restriction base="xs:string">
            <xs:enumeration value="void"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="null" type="f:null"/>
    <xs:simpleType name="null">
        <xs:restriction base="xs:string">
            <xs:enumeration value="null"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
